\subsection{Ableiten der Anforderungen an den Prototypen}
\label{sec:analysis_requirements}
    Aus den in \fref{sec:analysis_cvss} gefundenen Schwachstellen und Sicherheitslücken lassen sich direkt folgende Anforderungen ableiten, die diese vermeiden:
    \begin{itemize}
        \item Sicherung der (relevanten) Daten, bevor diese auf dem Mobilgerät gespeichert werden\cite{Ye2017}
        \item sicheres Kommunikationsprotokoll für die Dateiübertragung via Bluetooth\cite{Ye2017}
        \item Authentifizierung des Nutzers und des Smart Locks, um sicherzustellen, dass niemand anderes den zwischen beiden Parteien steht (Man-In-The-Middle)\cite{Ye2017}
        \item Mandatory Access Control für die Systeme, Daten auf den Systemen und Funktionen innerhalb eines Systems.\cite{Ye2017}
        \item Priorisierung der Befehle\cite{Ye2017} je nach Rolle.
        \item evtl: Authentifizierung des Clients gegeüber dem Nutzer und umgekehrt.\cite{Ye2017}
        \item For smart locks that follow a DGC architecture, state consistency attacks fundamentally arise because they are distributed systems, and their design does not provide consistency in the face of network partitions. Recall the CAP Theorem for distributed systems: it states that if network partitions can occur, it is impossible to provide full availability for the system's service, while simultaneously maintaining the latest, consistent state across all nodes in the system.
        Thus, no distributed system can provide perfect consistency and availability in the face of partitions.\cite{Ho2016} \\
        Nach \citeauthor{Ho2016}:
        Als verteiltes System gesehen: Schloss, remote Server und Endgeräte sind Knoten.
        Betrachtet man die Architektur von August, Danalock und co., die die letzte Entscheidung, ob ein Nutzer nun autorisiert ist oder nicht dem Engerät eines Nutzers überlassen, entsteht folgende Situation:
        Kann sich ein Endgerät des Nutzers sich nicht mit dem remote Server verbinden, entsteht eine Partitionierung im Netzwerk, durch welche das Engerät keinen Zugriff auf die authoritative Zugriffsliste hat.
        Demnach muss sich das Gerät entscheiden, ob es alle Zugriffe zulässt(um die Verfügbarkeit zu gewährleisten) oder alle Zugriffe blockiert, bis wieder eine Verbindung hergestellt werden kann.
        In der Zwischenzeit könnte sich die Liste ja wieder geändert und er Nutzer keine Autorisierung mehr haben (Konsistenz ist nicht mehr gegeben).
        \item \textrightarrow "eventual consistency" design \textrightarrow robuste revocation und logging Mechanismen und gleicheitige Unabhängigkeit des Systems von externen Entitäten\cite{Ho2016} \textrightarrow availability, weniger anfällig gegenüber remote Angriffen, indem den Geräten kein Zugriff zum Internet gewährt wird.
        \item gegen Relay-Attacken: Distance-boudning Protocols, die via RTT die Distany des Nutzers zum Schloss bestimmen, leider aber noch nicht verfügbar\cite{Ho2016}   
    \end{itemize}
    
    Sicherheitsziele von Smart Locks\cite{Ho2016}
    \begin{itemize}
        \item nicht-authorisierten Zugriff verhindern bzw. nur dann öffnen/schließen, wenn der Nutzer, der den Befehl gibt, authorisiert ist(Whitelisting)
        \item Access Log Integrität
    \end{itemize}
	
	Weiterhin lassen sich mittels den Ressourcen des \gls{owasp}-Projekts\cite{Miessler2015}\cite{Miessler2015a} weitere Anforderungen aufstellen\todo[color=orange]{besser ausdrücken}:
	\begin{itemize}
	    \item 
	\end{itemize}