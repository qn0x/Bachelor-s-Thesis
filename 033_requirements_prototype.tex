\subsection{Ableiten der Anforderungen an den Prototypen}
\label{sec:analysis_requirements}

    Aus den in \fref{sec:analysis_cvss} gefundenen Schwachstellen und Sicherheitslücken lassen sich einige Anforderungen ableiten, welche mit deren Umsetzung dabei helfen diese zu vermeiden.
    Ebenso werden die Anforderungen nach der Möglichkeit und Unmöglichkeit der Umsetzung mittels einer Blockchain gruppiert.
    Außerdem: Falls dies der Fall ist, einer Referenz auf die Schwachstelle, aus der die Anforderung entstanden ist.
    \noindent Möglich:
    \begin{itemize}
        \item Authentifizierung des Nutzers und des Smart Locks, speziell auch das Sicherstellen, dass die empfangenen Daten von der Richtigen Quelle kommen, um sicherzustellen, dass niemand anderes den zwischen beiden Parteien steht und Nachrichten manipulieren kann (Man-In-The-Middle) \textrightarrow\ \hyperref[vuln:phishing]{Phishing}, \hyperref[vuln:replay]{Replay}, \hyperref[vuln:spoofing]{Device Spoofing}, 
        \item Mandatory Access Control für die Systeme, Daten auf den Systemen und Funktionen innerhalb eines Systems \textrightarrow\ \hyperref[vuln:user_data]{Extracted User Data}, \hyperref[vuln:user_settings]{Stolen User Settings}
        \item Priorisierung der an das Schloss gesendeten Befehle\cite{Ye2017}.
        \item evtl: Authentifizierung des Clients gegeüber dem Nutzer und umgekehrt.\cite{Ye2017}
        \item Gegen Angriffe, die eine Diskrepanz des aktuellen Zustands Systems zwischen verschiedenen Teilnehmer und Knoten im Netzwerk ausnutzen: 
        For smart locks that follow a DGC architecture, state consistency attacks fundamentally arise because they are distributed systems, and their design does not provide consistency in the face of network partitions. Recall the CAP Theorem for distributed systems: it states that if network partitions can occur, it is impossible to provide full availability for the system's service, while simultaneously maintaining the latest, consistent state across all nodes in the system.
        Thus, no distributed system can provide perfect consistency and availability in the face of partitions.\cite{Ho2016} \\
        Nach \citeauthor{Ho2016}:
        Als verteiltes System gesehen: Schloss, remote Server und Endgeräte sind Knoten.
        Betrachtet man die Architektur von August, Danalock und co., die die letzte Entscheidung, ob ein Nutzer nun autorisiert ist oder nicht dem Engerät eines Nutzers überlassen, entsteht folgende Situation:
        Kann sich ein Endgerät des Nutzers sich nicht mit dem remote Server verbinden, entsteht eine Partitionierung im Netzwerk, durch welche das Engerät keinen Zugriff auf die authoritative Zugriffsliste hat.
        Demnach muss sich das Gerät entscheiden, ob es alle Zugriffe zulässt(um die Verfügbarkeit zu gewährleisten) oder alle Zugriffe blockiert, bis wieder eine Verbindung hergestellt werden kann.
        In der Zwischenzeit könnte sich die Liste ja wieder geändert und er Nutzer keine Autorisierung mehr haben (Konsistenz ist nicht mehr gegeben).
        \item \textrightarrow "eventual consistency" design \textrightarrow robuste revocation und logging Mechanismen und gleicheitige Unabhängigkeit des Systems von externen Entitäten\cite{Ho2016} \textrightarrow availability, weniger anfällig gegenüber remote Angriffen, indem den Geräten kein Zugriff zum Internet gewährt wird.
        \item gegen Relay-Attacken: Distance-boudning Protocols, die via RTT die Distany des Nutzers zum Schloss bestimmen, leider aber noch nicht verfügbar\cite{Ho2016} \item ein Angreifer ändert das Passwort der August Smartphone App auf einem temporär komprommittierten Gerät.
	        Szenario: Alice ist in der App angemeldet und der Angreifer erhält Zugriff auf dessen Smartphone.
	        Der Angreifer kann problemlos das Passwort von Alice ändern, da bei einer Änderung nicht mit dem alten Passwort verfiziert wird.
	        Somit kann ein Angreifer sich auf dem Gerät von Alice nach Belieben anmelden und in ihrem Namen Aktionen ausführen.
	        Jedoch kann der Angreifer sich nicht mit den Nutzerdaten von Alice auf einem anderen Gerät anmelden, da die App beim Anmelden auf einem neuen Gerät eine einmal gültige Verifikation über E-Mail oder SMS erfordert.\todo[color=yellow]{besser ausdrücken}
	        Hat nicht funktioniert \textrightarrow Server gibt die Zeit vor \cite{Fuller2017}
        \item nicht-authorisierten Zugriff verhindern bzw. nur dann öffnen/schließen, wenn der Nutzer, der den Befehl gibt, authorisiert ist(Whitelisting) \cite{Ho2016}
        \item Access Log Integrität \cite{Ho2016}
    \end{itemize}
    \noindent Unmöglich:
    \begin{itemize}
        \item Sicherung der (relevanten) Daten, bevor diese auf dem Mobilgerät gespeichert werden\cite{Ye2017}
        \item sicheres Kommunikationsprotokoll für jegliche Nachrichten\cite{Miessler,Ye2017}
        \item keine Hardcoded Paasswörter\cite{Rose2016}
        \item 2-Factor Authentication\cite{Rose2016}
        \item Bei Verwendung eines Nonce-Wertes: echt zufälliger Nonce-Wert mit 8-16 Bytes\cite{Rose2016}
        \item ordentlich implementierte AES-Verschlüsselung\cite{Rose2016}
    \end{itemize}
    